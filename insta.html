<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thermal Ripple Ultimate</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #000; color: #e5e5e5; }
        
        /* Custom Range Slider */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px; /* Slightly thicker for better visibility */
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
            cursor: pointer;
            transition: transform 0.1s;
            margin-top: -5px; /* Alignment fix */
        }
        /* For Firefox */
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border: none;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            border-radius: 3px;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.3);
            background: #ff5500; /* Accent color on hover */
        }

        /* 3x3 Grid Radio Styling */
        .anchor-radio:checked + div {
            background-color: #ff5500;
            border-color: #ff5500;
        }
        
        /* Utility */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #111; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // --- Inline SVG Icons ---
        const IconImage = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <rect width="18" height="18" x="3" y="3" rx="2" ry="2"/>
                <circle cx="9" cy="9" r="2"/>
                <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/>
            </svg>
        );
        const IconSliders = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <line x1="4" x2="4" y1="21" y2="14"/>
                <line x1="4" x2="4" y1="10" y2="3"/>
                <line x1="12" x2="12" y1="21" y2="12"/>
                <line x1="12" x2="12" y1="8" y2="3"/>
                <line x1="20" x2="20" y1="21" y2="16"/>
                <line x1="20" x2="20" y1="12" y2="3"/>
                <line x1="2" x2="6" y1="14" y2="14"/>
                <line x1="10" x2="14" y1="8" y2="8"/>
                <line x1="18" x2="22" y1="16" y2="16"/>
            </svg>
        );
        const IconMove = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="5 9 2 12 5 15"/>
                <polyline points="9 5 12 2 15 5"/>
                <polyline points="15 19 12 22 9 19"/>
                <polyline points="19 9 22 12 19 15"/>
                <line x1="2" x2="22" y1="12" y2="12"/>
                <line x1="12" x2="12" y1="2" y2="22"/>
            </svg>
        );
        const IconRefresh = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                <path d="M3 3v5h5"/>
                <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/>
                <path d="M16 16h5v5"/>
            </svg>
        );
        const IconDownload = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="7 10 12 15 17 10"/>
                <line x1="12" x2="12" y1="15" y2="3"/>
            </svg>
        );
        const IconVideo = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="23 7 16 12 23 17 23 7"></polygon>
                <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
            </svg>
        );

        // --- WebGL Shader Source ---

        const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
                v_texCoord = a_texCoord;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            uniform sampler2D u_image;
            uniform float u_time;
            
            // Distortion Params
            uniform float u_speed;
            uniform float u_frequency;
            uniform float u_intensity;
            uniform float u_ellipse; 
            uniform vec2 u_center; 
            uniform float u_aspect;

            // Appearance Params
            uniform bool u_isThermal;
            uniform bool u_isGrayscale; 
            uniform float u_hue;
            uniform float u_threshold; 
            uniform float u_smoothness; // Now controls Blur Radius

            varying vec2 v_texCoord;

            // 1. Hue Rotation
            vec3 hueShift(vec3 color, float hue) {
                const vec3 k = vec3(0.57735, 0.57735, 0.57735);
                float cosAngle = cos(hue);
                return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));
            }

            // 2. Thermal Gradient Map
            vec3 getThermalColor(float value) {
                vec3 c1 = vec3(0.05, 0.0, 0.2);  // Deep Dark Purple
                vec3 c2 = vec3(0.0, 0.0, 1.0);   // Blue
                vec3 c3 = vec3(0.0, 1.0, 1.0);   // Cyan
                vec3 c4 = vec3(1.0, 1.0, 0.0);   // Yellow
                vec3 c5 = vec3(1.0, 0.2, 0.0);   // Red-Orange

                vec3 col;
                if(value < 0.25) col = mix(c1, c2, value * 4.0);
                else if(value < 0.5) col = mix(c2, c3, (value - 0.25) * 4.0);
                else if(value < 0.75) col = mix(c3, c4, (value - 0.5) * 4.0);
                else col = mix(c4, c5, (value - 0.75) * 4.0);
                
                return col;
            }

            void main() {
                vec2 uv = v_texCoord;
                
                // --- Step 1: Ripple Distortion (Reverse/Inwards) ---
                vec2 distVec = uv - u_center;
                distVec.x *= u_aspect; 
                distVec.y *= u_ellipse; 
                
                float dist = length(distVec);
                float wave = sin(dist * u_frequency + (u_time * u_speed)) * u_intensity;
                
                vec2 distortion = normalize(distVec) * wave * 0.02; 
                vec2 distortedUV = uv + distortion;

                // --- Step 2: Fetch Color (With Gaussian-like Blur) ---
                vec3 finalColor;
                
                // Simple 5x5 Box Blur implementation
                // This mimics Gaussian blur by averaging neighbors
                if (u_smoothness > 0.0) {
                    vec3 colSum = vec3(0.0);
                    float total = 0.0;
                    float radius = u_smoothness * 0.02; // Scale blur strength

                    // Optimized 5x5 kernel loop
                    for (float x = -2.0; x <= 2.0; x += 1.0) {
                        for (float y = -2.0; y <= 2.0; y += 1.0) {
                            vec2 offset = vec2(x, y) * radius;
                            colSum += texture2D(u_image, clamp(distortedUV + offset, 0.0, 1.0)).rgb;
                            total += 1.0;
                        }
                    }
                    finalColor = colSum / total;
                } else {
                    finalColor = texture2D(u_image, clamp(distortedUV, 0.0, 1.0)).rgb;
                }


                // --- Step 3: Silhouette & Thermal Mapping ---
                if (u_isThermal) {
                    // Convert to Grayscale (Luminance)
                    float lum = dot(finalColor, vec3(0.299, 0.587, 0.114));
                    
                    // --- Contrast & Threshold ---
                    float contrast = 1.3; 
                    float val = (lum - 0.5) * contrast + 0.5 + (u_threshold - 0.5);
                    val = clamp(val, 0.0, 1.0);

                    // REMOVED: Banding logic
                    // The blur above (Step 2) handles the "smoothness" now
                    
                    finalColor = getThermalColor(val);
                }

                // --- Step 4: Global Hue Shift ---
                if (u_hue != 0.0) {
                    finalColor = hueShift(finalColor, u_hue);
                }

                // --- Step 5: B&W Conversion (Post-Processing) ---
                if (u_isGrayscale) {
                    float gray = dot(finalColor, vec3(0.299, 0.587, 0.114));
                    finalColor = vec3(gray);
                }

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        const App = () => {
            const [image, setImage] = useState(null);
            const [isRecording, setIsRecording] = useState(false);
            
            // Core Parameters
            const [params, setParams] = useState({
                speed: 30,
                frequency: 200,
                intensity: 30,
                ellipse: 1.5,
                hue: 0,
                isThermal: true,
                isGrayscale: false,
                threshold: 0.4,
                smoothness: 0.0,   // Default 0 for no blur
                anchor: 'bottom-center'
            });

            const getAnchorCoords = (key) => {
                const map = {
                    'top-left':      [0.0, 0.0], 'top-center':      [0.5, 0.0], 'top-right':      [1.0, 0.0],
                    'center-left':   [0.0, 0.5], 'center':          [0.5, 0.5], 'center-right':   [1.0, 0.5],
                    'bottom-left':   [0.0, 1.0], 'bottom-center':   [0.5, 1.0], 'bottom-right':   [1.0, 1.0],
                };
                return map[key] || [0.5, 1.0];
            };

            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const requestRef = useRef();
            const timeRef = useRef(0);
            const glRef = useRef(null);
            const programRef = useRef(null);
            const textureRef = useRef(null);

            // WebGL Initialization Helper
            const initWebGL = (canvas) => {
                const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
                if (!gl) return null;

                // Create Shader Program
                const createShader = (type, source) => {
                    const s = gl.createShader(type);
                    gl.shaderSource(s, source);
                    gl.compileShader(s);
                    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                        console.error(gl.getShaderInfoLog(s));
                        return null;
                    }
                    return s;
                };

                const vs = createShader(gl.VERTEX_SHADER, vertexShaderSource);
                const fs = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
                const prog = gl.createProgram();
                gl.attachShader(prog, vs);
                gl.attachShader(prog, fs);
                gl.linkProgram(prog);
                gl.useProgram(prog);

                // Buffers (Full Quad) - Vertices
                const posBuf = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);
                
                const posLoc = gl.getAttribLocation(prog, "a_position");
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                // Texture Coordinates
                const texBuf = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 0,1, 1,0, 1,1]), gl.STATIC_DRAW);
                
                const texLoc = gl.getAttribLocation(prog, "a_texCoord");
                gl.enableVertexAttribArray(texLoc);
                gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);

                return { gl, prog };
            };

            // Setup
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = initWebGL(canvas);
                if (ctx) {
                    glRef.current = ctx.gl;
                    programRef.current = ctx.prog;
                }
            }, []);

            // Image Upload
            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const img = new Image();
                        img.onload = () => {
                            setImage(img);
                            const gl = glRef.current;
                            if (gl) {
                                // Texture Config
                                const tex = gl.createTexture();
                                gl.bindTexture(gl.TEXTURE_2D, tex);
                                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                                textureRef.current = tex;
                            }
                        };
                        img.src = evt.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };

            // Render Loop
            const render = () => {
                const gl = glRef.current;
                const prog = programRef.current;
                const canvas = canvasRef.current;
                
                if (!gl || !prog || !image) {
                    requestRef.current = requestAnimationFrame(render);
                    return;
                }

                // Force 9:16 Aspect Ratio
                const targetW = 1080;
                const targetH = 1920;
                
                if (canvas.width !== targetW || canvas.height !== targetH) {
                    canvas.width = targetW;
                    canvas.height = targetH;
                    gl.viewport(0, 0, targetW, targetH);
                }

                timeRef.current += 0.01;

                gl.uniform1f(gl.getUniformLocation(prog, "u_time"), timeRef.current);
                gl.uniform1f(gl.getUniformLocation(prog, "u_speed"), params.speed * 0.1);
                gl.uniform1f(gl.getUniformLocation(prog, "u_frequency"), params.frequency);
                gl.uniform1f(gl.getUniformLocation(prog, "u_intensity"), params.intensity * 0.01);
                gl.uniform1f(gl.getUniformLocation(prog, "u_ellipse"), params.ellipse);
                gl.uniform1i(gl.getUniformLocation(prog, "u_isThermal"), params.isThermal);
                gl.uniform1i(gl.getUniformLocation(prog, "u_isGrayscale"), params.isGrayscale);
                gl.uniform1f(gl.getUniformLocation(prog, "u_aspect"), targetW / targetH);
                gl.uniform1f(gl.getUniformLocation(prog, "u_hue"), params.hue * (Math.PI / 180));
                gl.uniform1f(gl.getUniformLocation(prog, "u_threshold"), params.threshold);
                gl.uniform1f(gl.getUniformLocation(prog, "u_smoothness"), params.smoothness);

                const anchor = getAnchorCoords(params.anchor);
                gl.uniform2f(gl.getUniformLocation(prog, "u_center"), anchor[0], anchor[1]);

                gl.drawArrays(gl.TRIANGLES, 0, 6);
                requestRef.current = requestAnimationFrame(render);
            };

            useEffect(() => {
                requestRef.current = requestAnimationFrame(render);
                return () => cancelAnimationFrame(requestRef.current);
            }, [image, params]);

            const saveImage = () => {
                if(!canvasRef.current) return;
                const link = document.createElement('a');
                link.download = `thermal_art_${Date.now()}.png`;
                link.href = canvasRef.current.toDataURL('image/png');
                link.click();
            };

            // Video Recording Logic
            const saveVideo = () => {
                const canvas = canvasRef.current;
                if (!canvas || isRecording) return;

                setIsRecording(true);
                const stream = canvas.captureStream(30);
                
                // Prefer MP4 (H.264) if supported for .mov capability
                let mimeType = 'video/webm;codecs=vp9';
                let extension = 'webm';

                if (MediaRecorder.isTypeSupported('video/mp4')) {
                    mimeType = 'video/mp4';
                    extension = 'mov'; // Since user requested .mov and MP4 container is compatible
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) {
                    mimeType = 'video/webm;codecs=h264';
                    extension = 'webm';
                }

                const mediaRecorder = new MediaRecorder(stream, { mimeType });
                const chunks = [];
                
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) chunks.push(e.data);
                };

                mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `thermal_video_${Date.now()}.${extension}`;
                    a.click();
                    setIsRecording(false);
                };

                mediaRecorder.start();

                // Stop after 15 seconds
                setTimeout(() => {
                    mediaRecorder.stop();
                }, 15000);
            };

            return (
                <div className="flex flex-col lg:flex-row h-screen bg-black overflow-hidden selection:bg-orange-500 selection:text-white">
                    
                    {/* Canvas Area */}
                    <div ref={containerRef} className="relative flex-1 bg-[#050505] flex items-center justify-center overflow-hidden group border-r border-[#222]">
                        {!image && (
                            <div className="text-center space-y-4 opacity-50 z-10 pointer-events-none">
                                <IconImage size={48} className="mx-auto text-gray-600"/>
                                <div>
                                    <h1 className="text-2xl font-bold tracking-tighter text-gray-300">THERMAL RIPPLE</h1>
                                    <p className="text-xs text-gray-500 uppercase tracking-widest mt-2">Upload Image to Initialize</p>
                                </div>
                            </div>
                        )}
                        <canvas ref={canvasRef} className="block max-w-full max-h-full object-contain shadow-2xl" />
                        
                        <label className="absolute inset-0 z-20 flex items-center justify-center cursor-pointer pointer-events-none">
                             <div className="pointer-events-auto bg-white/10 backdrop-blur-md border border-white/10 px-6 py-3 rounded-full text-xs font-bold hover:bg-white/20 transition-all opacity-0 group-hover:opacity-100 translate-y-4 group-hover:translate-y-0 duration-300 flex items-center gap-2">
                                <IconImage size={14}/> OPEN LIBRARY
                             </div>
                             <input type="file" className="hidden" onChange={handleImageUpload} accept="image/*" />
                        </label>
                    </div>

                    {/* Controls Sidebar */}
                    <div className="w-full lg:w-[400px] bg-[#0A0A0A] flex flex-col h-[50vh] lg:h-full z-30 shadow-2xl overflow-hidden">
                        
                        {/* Header */}
                        <div className="p-6 border-b border-[#222] bg-[#0f0f0f] flex justify-between items-center">
                            <h2 className="text-xs font-bold text-orange-500 tracking-[0.2em] flex items-center gap-2">
                                <IconSliders size={12}/> CONTROL PANEL
                            </h2>
                            <button onClick={() => setParams(p => ({...p, hue: 0, speed: 30, frequency: 200, intensity: 30, ellipse: 1.5, threshold: 0.4, smoothness: 0.0, isGrayscale: false}))} className="text-xs text-gray-600 hover:text-white transition-colors">
                                <IconRefresh size={12}/>
                            </button>
                        </div>

                        <div className="flex-1 overflow-y-auto p-6 space-y-10 custom-scrollbar">
                            
                            {/* 1. Silhouette & Color */}
                            <div className="space-y-6">
                                <div className="flex items-center justify-between">
                                    <label className="text-xs font-bold text-gray-400 tracking-wider">SILHOUETTE & COLOR</label>
                                </div>
                                <div className="grid grid-cols-2 gap-2">
                                    <button onClick={() => setParams(p => ({...p, isThermal: !p.isThermal}))} className={`px-2 py-3 text-[10px] font-bold rounded border transition-colors ${params.isThermal ? 'border-orange-500 text-orange-500 bg-orange-900/20' : 'border-gray-700 text-gray-500 bg-[#151515]'}`}>
                                        THERMAL {params.isThermal ? 'ON' : 'OFF'}
                                    </button>
                                    <button onClick={() => setParams(p => ({...p, isGrayscale: !p.isGrayscale}))} className={`px-2 py-3 text-[10px] font-bold rounded border transition-colors ${params.isGrayscale ? 'border-white text-white bg-white/20' : 'border-gray-700 text-gray-500 bg-[#151515]'}`}>
                                        MONOCHROME {params.isGrayscale ? 'ON' : 'OFF'}
                                    </button>
                                </div>
                                
                                <div className="space-y-4 px-1">
                                    {/* Threshold Slider */}
                                    <div className="space-y-2">
                                        <div className="flex justify-between text-[10px] text-gray-500 font-mono">
                                            <span>SILHOUETTE THRESHOLD</span>
                                            <span>{(params.threshold * 100).toFixed(0)}%</span>
                                        </div>
                                        <input 
                                            type="range" min="0" max="100" 
                                            value={params.threshold * 100} 
                                            onChange={(e) => setParams({...params, threshold: Number(e.target.value) / 100})}
                                            className="accent-white"
                                        />
                                    </div>

                                    {/* Blur/Smoothness Slider */}
                                    <div className="space-y-2">
                                        <div className="flex justify-between text-[10px] text-gray-500 font-mono">
                                            <span>SILHOUETTE BLUR (GAUSSIAN)</span>
                                            <span>{(params.smoothness * 100).toFixed(0)}%</span>
                                        </div>
                                        <input 
                                            type="range" min="0" max="100" 
                                            value={params.smoothness * 100} 
                                            onChange={(e) => setParams({...params, smoothness: Number(e.target.value) / 100})}
                                            className="accent-white"
                                        />
                                    </div>

                                    {/* Hue Slider */}
                                    <div className="space-y-2 pt-2">
                                        <div className="flex justify-between text-[10px] text-gray-500 font-mono">
                                            <span>GLOBAL HUE</span>
                                            <span>{params.hue}Â°</span>
                                        </div>
                                        <input 
                                            type="range" min="0" max="360" 
                                            value={params.hue} 
                                            onChange={(e) => setParams({...params, hue: Number(e.target.value)})}
                                            className="w-full"
                                            style={{
                                                background: 'linear-gradient(to right, #f87171, #fbbf24, #34d399, #60a5fa, #818cf8, #c084fc, #f87171)'
                                            }}
                                        />
                                    </div>
                                </div>
                            </div>

                            <hr className="border-[#222]" />

                            {/* 2. Anchor Point (Grid UI) */}
                            <div className="space-y-4">
                                <label className="text-xs font-bold text-gray-400 tracking-wider flex items-center gap-2">
                                    <IconMove size={12}/> RIPPLE ORIGIN
                                </label>
                                <div className="grid grid-cols-3 gap-2 w-32 mx-auto">
                                    {['top-left', 'top-center', 'top-right', 'center-left', 'center', 'center-right', 'bottom-left', 'bottom-center', 'bottom-right'].map(pos => (
                                        <label key={pos} className="cursor-pointer group relative">
                                            <input 
                                                type="radio" 
                                                name="anchor" 
                                                className="anchor-radio hidden" 
                                                checked={params.anchor === pos} 
                                                onChange={() => setParams({...params, anchor: pos})}
                                            />
                                            <div className="w-full aspect-square rounded border border-gray-700 hover:border-gray-500 transition-colors bg-[#111]"></div>
                                            {/* Tooltip for visual feedback */}
                                            {params.anchor === pos && (
                                                <div className="absolute inset-0 bg-orange-500 rounded shadow-[0_0_10px_rgba(255,85,0,0.5)]"></div>
                                            )}
                                        </label>
                                    ))}
                                </div>
                                <p className="text-center text-[10px] text-gray-600 font-mono">{params.anchor.toUpperCase().replace('-', ' ')}</p>
                            </div>

                            <hr className="border-[#222]" />

                            {/* 3. Ripple Physics */}
                            <div className="space-y-6">
                                <label className="text-xs font-bold text-gray-400 tracking-wider">WAVE PHYSICS</label>
                                {[
                                    { label: 'Flow Speed', key: 'speed', max: 100 },
                                    { label: 'Frequency', key: 'frequency', max: 600 },
                                    { label: 'Intensity', key: 'intensity', max: 100 },
                                ].map((control) => (
                                    <div key={control.key} className="space-y-2">
                                        <div className="flex justify-between text-[10px] text-gray-500 font-mono uppercase">
                                            <span>{control.label}</span>
                                            <span>{params[control.key]}</span>
                                        </div>
                                        <input 
                                            type="range" 
                                            min="0" 
                                            max={control.max} 
                                            value={params[control.key]} 
                                            onChange={(e) => setParams({...params, [control.key]: Number(e.target.value)})}
                                        />
                                    </div>
                                ))}

                                {/* Ellipse Slider */}
                                <div className="space-y-2">
                                    <div className="flex justify-between text-[10px] text-gray-500 font-mono uppercase">
                                        <span>ELLIPSE FACTOR</span>
                                        <span>{params.ellipse.toFixed(1)}</span>
                                    </div>
                                    <input 
                                        type="range" 
                                        min="0.5" 
                                        max="3.0" 
                                        step="0.1"
                                        value={params.ellipse} 
                                        onChange={(e) => setParams({...params, ellipse: Number(e.target.value)})}
                                    />
                                </div>
                            </div>
                        </div>

                        {/* Export Buttons */}
                        <div className="p-6 bg-[#0f0f0f] border-t border-[#222] grid grid-cols-2 gap-3">
                            <button 
                                onClick={saveImage}
                                disabled={!image}
                                className="w-full py-4 bg-white text-black font-bold text-sm tracking-widest hover:bg-gray-200 transition-colors rounded shadow-lg disabled:opacity-30 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                            >
                                <IconDownload size={16}/> IMAGE
                            </button>
                            <button 
                                onClick={saveVideo}
                                disabled={!image || isRecording}
                                className={`w-full py-4 font-bold text-sm tracking-widest rounded shadow-lg flex items-center justify-center gap-2 transition-colors ${isRecording ? 'bg-red-500 text-white animate-pulse' : 'bg-[#1a1a1a] text-white border border-[#333] hover:bg-[#222]'}`}
                            >
                                <IconVideo size={16}/> {isRecording ? 'REC...' : 'VIDEO (15s)'}
                            </button>
                        </div>

                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
